<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.8">
<meta name="Forrest-skin-name" content="pelt">
<title>JCC Features</title>
<link type="text/css" href="../../skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="../../skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="../../skin/print.css" rel="stylesheet">
<link type="text/css" href="../../skin/profile.css" rel="stylesheet">
<script src="../../skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="../../skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="../../skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="../../">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<!--+
    |breadtrail
    +-->
<div class="breadtrail">
<a href="http://www.apache.org/">apache</a> &gt; <a href="http://lucene.apache.org/">lucene</a><script src="../../skin/breadcrumbs.js" language="JavaScript" type="text/javascript"></script>
</div>
<!--+
    |header
    +-->
<div class="header">
<!--+
    |start group logo
    +-->
<div class="grouplogo">
<a href="http://lucene.apache.org/"><img class="logoImage" alt="Lucene" src="../../images/lucene_green_150.gif" title="Lucene Description"></a>
</div>
<!--+
    |end group logo
    +-->
<!--+
    |start Project Logo
    +-->
<div class="projectlogoA1">
<a href="http://lucene.apache.org/pylucene/"><img class="logoImage" alt="PyLucene" src="../../images/project.png" title="PyLucene Description"></a>
</div>
<!--+
    |end Project Logo
    +-->
<!--+
    |start Tabs
    +-->
<ul id="tabs">
<li>
<a class="unselected" href="../../index.html">PyLucene</a>
</li>
<li class="current">
<a class="selected" href="../../jcc/index.html">JCC</a>
</li>
</ul>
<!--+
    |end Tabs
    +-->
</div>
</div>
<div id="main">
<div id="publishedStrip">
<!--+
    |start Subtabs
    +-->
<div id="level2tabs"></div>
<!--+
    |end Endtabs
    +-->
<script type="text/javascript"><!--
document.write("Last Published: " + document.lastModified);
//  --></script>
</div>
<!--+
    |breadtrail
    +-->
<div class="breadtrail">

             &nbsp;
           </div>
<!--+
    |start Menu, mainarea
    +-->
<!--+
    |start Menu
    +-->
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', '../../skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('../../skin/images/chapter_open.gif');">JCC</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div onclick="SwitchMenu('menu_1.1.1', '../../skin/')" id="menu_1.1.1Title" class="menutitle">About</div>
<div id="menu_1.1.1" class="menuitemgroup">
<div class="menuitem">
<a href="../../jcc/index.html" title="Welcome to JCC">Index</a>
</div>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', '../../skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('../../skin/images/chapter_open.gif');">Documentation</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="../../jcc/documentation/install.html">Installation</a>
</div>
<div class="menupage">
<div class="menupagetitle">Features</div>
</div>
<div class="menuitem">
<a href="../../jcc/documentation/javadoc/index.html">Javadoc</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="../../skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<!--+
  |alternative credits
  +-->
<div id="credit2"></div>
</div>
<!--+
    |end Menu
    +-->
<!--+
    |start content
    +-->
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="readme.pdf"><img alt="PDF -icon" src="../../skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>JCC Features</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#install">Installing JCC</a>
</li>
<li>
<a href="#invoking">Invoking JCC</a>
</li>
<li>
<a href="#use">Generating C++ and Python wrappers with JCC</a>
</li>
<li>
<a href="#classpath">Classpath considerations</a>
</li>
<li>
<a href="#setuptools">Using distutils vs setuptools</a>
</li>
<li>
<a href="#egg">Distributing an egg</a>
</li>
<li>
<a href="#api">JCC's runtime API functions</a>
</li>
<li>
<a href="#casting">Type casting and instance checks</a>
</li>
<li>
<a href="#generics">Handling generic classes</a>
</li>
<li>
<a href="#arrays">Handling arrays</a>
</li>
<li>
<a href="#exceptions">Exception reporting</a>
</li>
<li>
<a href="#extensions">Writing Java class extensions in Python</a>
</li>
<li>
<a href="#embedding">Embedding a Python VM in a Java VM</a>
</li>
<li>
<a href="#python">Pythonic protocols</a>
</li>
</ul>
</div>
    
<div class="warning">
<div class="label">Warning</div>
<div class="content">
      Before calling any PyLucene API that requires the Java VM, start it by
      calling <span class="codefrag">initVM(classpath, ...)</span>. More about this function
      in <a href="#api">here</a>.
    </div>
</div>
    
<a name="N10017"></a><a name="install"></a>
<h2 class="boxed">Installing JCC</h2>
<div class="section">
<p>
        JCC is a Python extension written in Python and C++. It requires a
        Java Runtime Environment (JRE) to operate as it uses Java's
        reflection APIs to do its work. It is built and installed
        via <span class="codefrag">distutils</span> or <span class="codefrag">setuptools</span>.
      </p>
<p>
        See <a href="../../jcc/documentation/install.html">installation</a> for more
        information and operating system specific notes.
      </p>
</div>
    
<a name="N1002E"></a><a name="invoking"></a>
<h2 class="boxed">Invoking JCC</h2>
<div class="section">
<p>
        JCC is installed as a package and how to invoke it depends on the
        Python version used:
      </p>
<ul>
	
<li>python 2.7: <span class="codefrag">python -m jcc</span>
</li>
	
<li>python 2.6: <span class="codefrag">python -m jcc.__main__</span>
</li>
	
<li>python 2.5: <span class="codefrag">python -m jcc</span>
</li>
	
<li>python 2.4:
	  <ul>
	    
<li>no setuptools: <span class="codefrag">python </span><em><span class="codefrag">site-packages</span></em><span class="codefrag">/jcc/__init__.py</span>
</li>
	    
<li>with setuptools: <span class="codefrag">python </span><em><span class="codefrag">site-packages</span></em>/<em><span class="codefrag">jcc egg directory</span></em><span class="codefrag">/jcc/__init__.py</span>
</li>
	  
</ul>
	
</li>
	
<li>python 2.3: <span class="codefrag">python </span><em><span class="codefrag">site-packages</span></em>/<em><span class="codefrag">jcc egg directory</span></em><span class="codefrag">/jcc/__init__.py</span>
</li>
      
</ul>
</div>
    
<a name="N10076"></a><a name="use"></a>
<h2 class="boxed">Generating C++ and Python wrappers with JCC</h2>
<div class="section">
<p>
        JCC started as a C++ code generator for hiding the gory details of
        accessing methods and fields on Java classes via
        Java's <a href="http://java.sun.com/j2se/1.5.0/docs/guide/jni/spec/invocation.html">Native Invocation Interface</a>.
        These C++ wrappers make it possible to access a Java object as if it
        was a regular C++ object very much like GCJ's
        <a href="http://gcc.gnu.org/onlinedocs/gcj/About-CNI.html">CNI
        interface</a>.
      </p>
<p>
        It then became apparent that JCC could also generate the C++
        wrappers for making these classes available to Python. Every class
        that gets thus wrapped becomes a
        <a href="http://docs.python.org/ext/defining-new-types.html">CPython
        type</a>.
      </p>
<p>
        JCC generates wrappers for all public classes that are requested by
        name on the command line or via the <span class="codefrag">--jar</span> command line
        argument. It generates wrapper methods for all public methods and
        fields on these classes whose return type and parameter types are
        found in one of the following ways:
      </p>
<ul>
        
<li>
          the type is one of the requested classes
        </li>
        
<li>
          the type is one of the requested classes' superclass or implemented
          interfaces 
        </li>
        
<li>
          the type is available from one of the packages listed via the
          <span class="codefrag">--package</span> command line argument
        </li>
      
</ul>
<p>
	Overloaded methods are supported and are selected at runtime on the
	basis of the type and number of arguments passed in.
      </p>
<p>
        JCC does not generate wrappers for methods or fields which don't
        satisfy these requirements. Thus, JCC can avoid generating code for
        runaway transitive closures of type dependencies.
      </p>
<p>
        JCC generates property accessors for a property
        called <em><span class="codefrag">field</span></em> when it finds Java methods
        named <span class="codefrag">set</span><em><span class="codefrag">Field</span></em><span class="codefrag">(value)</span>,
        <span class="codefrag">get</span><em><span class="codefrag">Field</span></em><span class="codefrag">()</span> or
	<span class="codefrag">is</span><em><span class="codefrag">Field</span></em><span class="codefrag">()</span>.
      </p>
<p>
        The C++ wrappers are declared in a C++ namespace structure that
        mirrors the Java classes' Java packages. The Python types are
        declared in a flat namespace at the top level of the resulting
        Python extension module.
      </p>
<p>
        JCC's command-line arguments are best illustrated via the PyLucene
        example:
      </p>
<pre class="code">
    $ python -m jcc           # run JCC to wrap
        --jar lucene.jar      # all public classes in the lucene jar file
        --jar analyzers.jar   # and the lucene analyzers contrib package
        --jar snowball.jar    # and the snowball contrib package
        --jar highlighter.jar # and the highlighter contrib package
        --jar regex.jar       # and the regex search contrib package
        --jar queries.jar     # and the queries contrib package
        --jar extensions.jar  # and the Python extensions package
        --package java.lang   # including all dependencies found in the 
                              # java.lang package
        --package java.util   # and the java.util package
        --package java.io     # and the java.io package
          java.lang.System    # and to explicitely wrap java.lang.System
          java.lang.Runtime   # as well as java.lang.Runtime
          java.lang.Boolean   # and java.lang.Boolean
          java.lang.Byte      # and java.lang.Byte
          java.lang.Character # and java.lang.Character
          java.lang.Integer   # and java.lang.Integer
          java.lang.Short     # and java.lang.Short
          java.lang.Long      # and java.lang.Long
          java.lang.Double    # and java.lang.Double
          java.lang.Float     # and java.lang.Float
          java.text.SimpleDateFormat
                              # and java.text.SimpleDateFormat
          java.io.StringReader
                              # and java.io.StringReader
          java.io.InputStreamReader
                              # and java.io.InputStreamReader
          java.io.FileInputStream
                              # and java.io.FileInputStream
          java.util.Arrays    # and java.util.Arrays
        --exclude org.apache.lucene.queryParser.Token
                              # while explicitely not wrapping
                              # org.apache.lucene.queryParser.Token
        --exclude org.apache.lucene.queryParser.TokenMgrError
                              # nor org.apache.lucene.queryParser.TokenMgrError
        --exclude org.apache.lucene.queryParser.ParseException
                              # nor.apache.lucene.queryParser.ParseException
        --python lucene       # generating Python wrappers into a module
                              # called lucene
        --version 2.4.0       # giving the Python extension egg version 2.4.0
        --mapping org.apache.lucene.document.Document 
                  'get:(Ljava/lang/String;)Ljava/lang/String;' 
                              # asking for a Python mapping protocol wrapper
                              # for get access on the Document class by
                              # calling its get method
        --mapping java.util.Properties 
                  'getProperty:(Ljava/lang/String;)Ljava/lang/String;'
                              # asking for a Python mapping protocol wrapper
                              # for get access on the Properties class by
                              # calling its getProperty method
        --sequence org.apache.lucene.search.Hits
                   'length:()I' 
                   'doc:(I)Lorg/apache/lucene/document/Document;'
                              # asking for a Python sequence protocol wrapper
                              # for length and get access on the Hits class by
                              # calling its length and doc methods
        --files 2             # generating all C++ classes into about 2 .cpp
                              # files
        --build               # and finally compiling the generated C++ code
                              # into a Python egg via setuptools - when
                              # installed - or a regular Python extension via
                              # distutils or setuptools otherwise 
        --module collections.py
                              # copying the collections.py module into the egg
        --install             # installing it into Python's site-packages
                              # directory.
      </pre>
<p>
        There are limits to both how many files can fit on the command line
        and how large a C++ file the C++ compiler can handle. By default,
        JCC generates one large C++ file containing the source code for all
        wrapper classes.
      </p>
<p>
        Using the <span class="codefrag">--files</span> command line argument, this behaviour
        can be tuned to workaround various limits:<br>
        for example:
      </p>
<ul>
        
<li>
          to break up the large wrapper class file into about 2 files:<br>
          
<span class="codefrag">--files 2</span>
        
</li>
        
<li>
          to break up the large wrapper class file into about 10 files:<br>
          
<span class="codefrag"> --files 10</span>
        
</li>
        
<li>
          to generate one C++ file per Java class wrapped:<br>
          
<span class="codefrag">--files separate</span>
        
</li>
      
</ul>
<p>
        The <span class="codefrag">--prefix</span> and <span class="codefrag">--root</span> arguments are
        passed through to <span class="codefrag">distutils</span>' <span class="codefrag">setup()</span>.
      </p>
</div>
    
<a name="N10108"></a><a name="classpath"></a>
<h2 class="boxed">Classpath considerations</h2>
<div class="section">
<p>
        When generating wrappers for Python, the JAR files passed to JCC
        via <span class="codefrag">--jar</span> are copied into the resulting Python extension
        egg as resources and added to the extension
        module's <span class="codefrag">CLASSPATH</span> variable. Classes or JAR files that
        are required by the classes contained in the argument JAR files need
        to be made findable via JCC's <span class="codefrag">--classpath</span> command line
        argument. At runtime, these need to be appended to the
        extension's <span class="codefrag">CLASSPATH</span> variable before starting the VM
        with <span class="codefrag">initVM(CLASSPATH)</span>.
      </p>
<p>
        To have such required jar files also automatically copied into
        resulting Python extension egg and added to the classpath at build
        and runtime, use the <span class="codefrag">--include</span> option. This option
        works like the <span class="codefrag">--jar</span> option except that no wrappers are
        generated for the classes contained in them unless they're
        explicitely named on the command line. 
      </p>
<p>
	When more than one JCC-built extension module is going to be used in
	the same Python VM and these extension modules share Java classes,
	only one extension module should be generated with wrappers for these
	shared classes. The other extension modules must be built by importing
	the one with the shared classes by using the <span class="codefrag">--import</span>
	command line parameter. This ensures that only one copy of the
	wrappers for the shared classes are generated and that they are
	compatible among all extension modules sharing them.
      </p>
</div>
    
<a name="N10130"></a><a name="setuptools"></a>
<h2 class="boxed">Using distutils vs setuptools</h2>
<div class="section">
<p>
        By default, when building a Python extension,
        if <span class="codefrag">setuptools</span> is found to be installed, it is used
        over <span class="codefrag">distutils</span>. If you want to force the use
        of <span class="codefrag">distutils</span> over <span class="codefrag">setuptools</span>, use
        the <span class="codefrag">--use-distutils</span> command line argument.
      </p>
</div>
    
<a name="N1014E"></a><a name="egg"></a>
<h2 class="boxed">Distributing an egg</h2>
<div class="section">
<p>
        The <span class="codefrag">--bdist</span> option can be used to ask JCC to
        invoke <span class="codefrag">distutils</span> with <span class="codefrag">bdist</span>
        or <span class="codefrag">setuptools</span>
        with <span class="codefrag">bdist_egg</span>. If <span class="codefrag">setuptools</span> is used,
        the resulting egg has to be installed with the
        <a href="http://peak.telecommunity.com/DevCenter/EasyInstall"><span class="codefrag">easy_install</span></a>
        installer which is normally part of a Python installation that
        includes <span class="codefrag">setuptools</span>.
      </p>
</div>
    
<a name="N10172"></a><a name="api"></a>
<h2 class="boxed">JCC's runtime API functions</h2>
<div class="section">
<p>
        JCC includes a small runtime component that is compiled into any
        Python extension it produces.
      </p>
<p>
        This runtime component makes it possible to manage the Java VM from
        Python. Because a Java VM can be configured with a myriad of
        options, it is not automatically started when the resulting Python
        extension module is loaded into the Python interpreter.
      </p>
<p>
        Instead, the <span class="codefrag">initVM()</span> function must be called from the
        main thread before using any of the wrapped classes. It takes the
        following keyword arguments:
      </p>
<ul>
        
<li>
          
<span class="codefrag">classpath</span>
<br>
          A string containing one or more directories or jar files for the
          Java VM to search for classes. Every Python extension produced by
          JCC exports a <span class="codefrag">CLASSPATH</span> variable that is hardcoded to
          the jar files that it was produced from. A copy of each jar file
          is installed as a resource file with the extension when JCC is
          invoked with the <span class="codefrag">--install</span> command line argument. 
	  This parameter is optional and defaults to the
	  <span class="codefrag">CLASSPATH</span> string exported by the module
          <span class="codefrag">initVM</span> is imported from.
          <pre class="code">
            &gt;&gt;&gt; import lucene
            &gt;&gt;&gt; lucene.initVM(classpath=lucene.CLASSPATH)
          </pre>
        
</li>
        
<li>
          
<span class="codefrag">initialheap</span>
<br>
          The initial amount of Java heap to start the Java VM with. This
          argument is a string that follows the same syntax as the
          similar <span class="codefrag">-Xms</span> java command line argument.
          <pre class="code">
            &gt;&gt;&gt; import lucene
            &gt;&gt;&gt; lucene.initVM(initialheap='32m')
            &gt;&gt;&gt; lucene.Runtime.getRuntime().totalMemory()
            33357824L
          </pre>
        
</li>
        
<li>
          
<span class="codefrag">maxheap</span>
<br>
          The maximum amount of Java heap that could become available to the
          Java VM. This argument is a string that follows the same syntax as
          the similar <span class="codefrag">-Xmx</span> java command line argument.
        </li>
        
<li>
          
<span class="codefrag">maxstack</span>
<br>
          The maximum amount of stack space that available to the Java
          VM. This argument is a string that follows the same syntax as the
          similar <span class="codefrag">-Xss</span> java command line argument.
        </li>
        
<li>
          
<span class="codefrag">vmargs</span>
<br>
          A string of comma separated additional options to pass to the VM
          startup rountine. These are passed through as-is. For example:
          <pre class="code">
            &gt;&gt;&gt; import lucene
            &gt;&gt;&gt; lucene.initVM(vmargs='-Xcheck:jni,-verbose:jni,-verbose:gc')
          </pre>
        
</li>
      
</ul>
<p>
        The <span class="codefrag">initVM()</span> and <span class="codefrag">getVMEnv()</span> functions
        return a JCCEnv object that has a few utility methods on it:
      </p>
<ul>
        
<li>
          
<span class="codefrag">attachCurrentThread(name, asDaemon)</span>
<br>
          Before a thread created in Python or elsewhere but not in the Java
          VM can be used with the Java VM, this method needs to be
          invoked. The two arguments it takes are optional and
          self-explanatory.
        </li>
        
<li>
          
<span class="codefrag">detachCurrentThread()</span>
          The opposite of <span class="codefrag">attachCurrentThread()</span>. This method
          should be used with extreme caution as Python's and java VM's
          garbage collectors may use a thread detached too early causing a
          system crash. The utility of this method seems dubious at the
          moment.
        </li>
      
</ul>
<p>
        There are several differences between JNI's <span class="codefrag">findClass()</span>
        and Java's <span class="codefrag">Class.forName()</span>:
      </p>
<ul>
        
<li>
          className is a '/' separated string of names
        </li>
        
<li>
          the class loaders are different, <span class="codefrag">findClass()</span> may find
          classes that <span class="codefrag">Class.forName()</span> won't.
        </li>
      
</ul>
<p>
        For example:
      </p>
<pre class="code">
        &gt;&gt;&gt; from lucene import *
        &gt;&gt;&gt; initVM(CLASSPATH)
        &gt;&gt;&gt; findClass('org/apache/lucene/document/Document')
        &lt;Class: class org.apache.lucene.document.Document&gt;
        &gt;&gt;&gt; Class.forName('org.apache.lucene.document.Document')
        Traceback (most recent call last):
          File "&lt;stdin&gt;", line 1, in &lt;module&gt;
        lucene.JavaError: java.lang.ClassNotFoundException:
                          org/apache/lucene/document/Document
        &gt;&gt;&gt; Class.forName('java.lang.Object')
        &lt;Class: class java.lang.Object&gt;
      </pre>
</div>
    
<a name="N10207"></a><a name="casting"></a>
<h2 class="boxed">Type casting and instance checks</h2>
<div class="section">
<p>
	Many Java APIs are declared to return types that are less specific
	than the types actually returned. In Java 1.5, this is worked around
	with type parameters. JCC generates code to heed type parameters
	unless the <span class="codefrag">--no-generics</span> is used. See next section for
	details on Java generics support.
      </p>
<p>
	In C++, casting the object into its actual type is supported via the
	regular C casting operator.
      </p>
<p>
	In Python each wrapped class has a class method
	called <span class="codefrag">cast_</span> that implements the same functionality.
      </p>
<p>
	Similarly, each wrapped class has a class method
	called <span class="codefrag">instance_</span> that tests whether the wrapped java
	instance is of the given type. For example:
      </p>
<pre class="code">
	if BooleanQuery.instance_(query):
            booleanQuery = BooleanQuery.cast_(query)

        print booleanQuery.getClauses()
      </pre>
</div>
    
<a name="N10227"></a><a name="generics"></a>
<h2 class="boxed">Handling generic classes</h2>
<div class="section">
<p>
	Java 1.5 added support for parameterized types. JCC generates code
	to heed type parameters unless the <span class="codefrag">--no-generics</span>
	command line parameter is used. Java type parameterization is a
	runtime feature. The same class is used for all its
	parameterizations. Similarly, JCC wrapper objects all use the same
	class but store type parameterizations on instances and make them
	accessible as a tuple via the <span class="codefrag">parameters_</span> property.
      </p>
<p>
	For example, an <span class="codefrag">ArrayList&lt;Document&gt;</span> instance,
	has <span class="codefrag">(&lt;type 'Document'&gt;,)</span>
	for <span class="codefrag">parameters_</span> and its <span class="codefrag">get()</span> method uses
	that type parameter to wrap its return values.
      </p>
<p>
	To allocate an instance of a generic Java class with specific type
	parameters use the <span class="codefrag">of_()</span> method. This method accepts
	one or more Python wrapper classes to use as type parameters. For
	example, <span class="codefrag">java.util.ArrayList&lt;E&gt;</span> is declared to
	accept one type parameter. Its wrapper's <span class="codefrag">of_()</span> method
	hence accepts one parameter, a Python class, to use as type
	parameter for the return type of its <span class="codefrag">get()</span> method, among
	others: 
      </p>
<pre class="code">
	&gt;&gt;&gt; a = ArrayList().of_(Document)
	&gt;&gt;&gt; a
        &lt;ArrayList: []&gt;
	&gt;&gt;&gt; a.parameters_
	(&lt;type 'Document'&gt;,)
        &gt;&gt;&gt; a.add(Document())
        True
        &gt;&gt;&gt; a.get(0)
        &lt;Document: Document&lt;&gt;&gt;
      </pre>
<p>
	The use of type parameters is, of course, optional. A generic Java
	class can still be used as before, without type parameters.
	Downcasting from <span class="codefrag">Object</span> is then necessary:  
      </p>
<pre class="code">
	&gt;&gt;&gt; a = ArrayList()
	&gt;&gt;&gt; a
        &lt;ArrayList: []&gt;
	&gt;&gt;&gt; a.parameters_
	(None,)
        &gt;&gt;&gt; a.add(Document())
        True
        &gt;&gt;&gt; a.get(0)
        &lt;Object: Document&lt;&gt;&gt;
        &gt;&gt;&gt; Document.cast_(a.get(0))
        &lt;Document: Document&lt;&gt;&gt;
      </pre>
</div>
    
<a name="N10263"></a><a name="arrays"></a>
<h2 class="boxed">Handling arrays</h2>
<div class="section">
<p>
	Java arrays are wrapped with a C++ JArray
	template. The <span class="codefrag">[]</span> is available for read
	access. This template, <span class="codefrag">JArray&lt;T&gt;</span>, accomodates all
	java primitive types, <span class="codefrag">jstring</span>, <span class="codefrag">jobject</span> and
	wrapper class arrays.
      </p>
<p>
	Java arrays are returned to Python in a <span class="codefrag">JArray</span> wrapper
	instance that implements the Python sequence protocol. It is
	possible to change an array's elements but not to change an array's
	size.
      </p>
<p>
	To convert a char array to a Python string use
	a <span class="codefrag">''.join(array)</span> construct.
      </p>
<p>
	Any Java method expecting an array can be called with the corresponding
	sequence object from python.
      </p>
<p>
	To instantiate a Java array from Python, use one of the following
	forms:
      </p>
<pre class="code">
	&gt;&gt;&gt; array = JArray('int')(size)
	# the resulting Java int array is initialized with zeroes

	&gt;&gt;&gt; array = JArray('int')(sequence)
	# the sequence must only contain ints
	# the resulting Java int array contains the ints in the sequence
      </pre>
<p>
	Instead of <span class="codefrag">'int'</span>, you may also use one
	of <span class="codefrag">'object'</span>, <span class="codefrag">'string'</span>, <span class="codefrag">'bool'</span>,
	<span class="codefrag">'byte'</span>, <span class="codefrag">'char'</span>, <span class="codefrag">'double'</span>,
	<span class="codefrag">'float'</span>, <span class="codefrag">'long'</span> and <span class="codefrag">'short'</span>
	to create an array of the corresponding type.
      </p>
<p>
	Because there is only one wrapper class for object arrays,
	the <span class="codefrag">JArray('object')</span> type's constructor takes a second
	argument denoting the class of the object elements. This argument is
	optional and defaults to <span class="codefrag">Object</span>.
      </p>
<p>
	As with the <span class="codefrag">Object</span> types, the <span class="codefrag">JArray</span> types
	also include a <span class="codefrag">cast_</span> method. This method becomes useful
	when the array returned to Python is wrapped as a
	plain <span class="codefrag">Object</span>. This is the case, for example, with
	nested arrays since there is no distinct Python type for every
	different java object array class - all java object arrays are
	wrapped by <span class="codefrag">JArray('object')</span>. For example:
      </p>
<pre class="code">
	# cast obj to an array of ints
        &gt;&gt;&gt; JArray('int').cast_(obj)
	# cast obj to an array of Document
        &gt;&gt;&gt; JArray('object').cast_(obj, Document)
      </pre>
<p>
	In both cases, the java type of obj must be compatible with the
	array type it is being cast to.
      </p>
<pre class="code">
	# using nested array:

        &gt;&gt;&gt; d = JArray('object')(1, Document)
        &gt;&gt;&gt; d[0] = Document()
        &gt;&gt;&gt; d
        JArray&lt;object&gt;[&lt;Document: Document&lt;&gt;&gt;]
        &gt;&gt;&gt; d[0]
        &lt;Document: Document&lt;&gt;&gt;
        &gt;&gt;&gt; a = JArray('object')(2)
        &gt;&gt;&gt; a[0] = d
        &gt;&gt;&gt; a[1] = JArray('int')([0, 1, 2])
        &gt;&gt;&gt; a
        JArray&lt;object&gt;[&lt;Object: [Lorg.apache.lucene.document.Document;@694f12&gt;, &lt;Object: [I@234265&gt;]
        &gt;&gt;&gt; a[0]
        &lt;Object: [Lorg.apache.lucene.document.Document;@694f12&gt;
        &gt;&gt;&gt; a[1]
        &lt;Object: [I@234265&gt;
        &gt;&gt;&gt; JArray('object').cast_(a[0])[0]
        &lt;Object: Document&lt;&gt;&gt;
        &gt;&gt;&gt; JArray('object').cast_(a[0], Document)[0]
        &lt;Document: Document&lt;&gt;&gt;
        &gt;&gt;&gt; JArray('int').cast_(a[1])
        JArray&lt;int&gt;[0, 1, 2]
        &gt;&gt;&gt; JArray('int').cast_(a[1])[0]
        0
      </pre>
<p>
	To verify that a Java object is of a given array type, use
	the <span class="codefrag">instance_()</span> method available on the array
	type. This is not the same as verifying that it is assignable with
	elements of a given type. For example, using the arrays created
	above:
      </p>
<pre class="code">
	# is d array of Object ? are d's elements of type Object ?
        &gt;&gt;&gt; JArray('object').instance_(d)
        True

	# can it receive Object instances ?
        &gt;&gt;&gt; JArray('object').assignable_(d)
        False

	# is it array of Document ? are d's elements of type Document ?
        &gt;&gt;&gt; JArray('object').instance_(d, Document)
        True

	# is it array of Class ? are d's elements of type Class ?
        &gt;&gt;&gt; JArray('object').instance_(d, Class)
        False

	# can it receive Document instances ?
        &gt;&gt;&gt; JArray('object').assignable_(d, Document)
        True
      </pre>
</div>
    
<a name="N102E0"></a><a name="exceptions"></a>
<h2 class="boxed">Exception reporting</h2>
<div class="section">
<p>
	Exceptions that occur in the Java VM and that escape to C++ are
	reported as a <span class="codefrag">javaError</span> C++ exception. When using
	Python wrappers, the C++ exceptions are handled and reported with
	Python exceptions. When using C++ only, failure to handle the
	exception in your C++ code will cause the process to crash.
      </p>
<p>
	Exceptions that occur in the Java VM and that escape to the Python
	VM are reported with a <span class="codefrag">JavaError</span> python exception
	object. The <span class="codefrag">getJavaException()</span> method can be called
	on <span class="codefrag">JavaError</span> objects to obtain the original java
	exception object wrapped as any other Java object. This Java object
	can be used to obtain a Java stack trace for the error, for example.
      </p>
<p>
	Exceptions that occur in the Python VM and that escape to the Java
	VM, as for example can happen in Python extensions (see topic below)
	are reported to the Java VM as a <span class="codefrag">RuntimeException</span> or as
	a <span class="codefrag">PythonException</span> when using shared
	mode. See <a href="../../jcc/documentation/install.html">installation
	instructions</a> for more information about shared mode.
      </p>
</div>
    
<a name="N10306"></a><a name="extensions"></a>
<h2 class="boxed">Writing Java class extensions in Python</h2>
<div class="section">
<p>
	JCC makes it relatively easy to extend a Java class from
	Python. This is done via an intermediary class written in Java that
	implements a special method called <span class="codefrag">pythonExtension()</span>
	and that declares a number of native methods that are to be
	implemented by the actual Python extension.
      </p>
<p>
	When JCC sees these special extension java classes it generates the
	C++ code implementing the native methods they declare. These native
	methods call the corresponding Python method implementations passing
	in parameters and returning the result to the Java VM caller.
      </p>
<p>
	For example, to implement a Lucene analyzer in Python, one would
	implement first such an extension class in Java:
      </p>
<pre class="code">
    package org.apache.pylucene.analysis;

    import org.apache.lucene.analysis.Analyzer;
    import org.apache.lucene.analysis.TokenStream;
    import java.io.Reader;

    public class PythonAnalyzer extends Analyzer {
        private long pythonObject;

        public PythonAnalyzer()
        {
        }

        public void pythonExtension(long pythonObject)
        {
            this.pythonObject = pythonObject;
        }
        public long pythonExtension()
        {
            return this.pythonObject;
        }

        public void finalize()
            throws Throwable
        {
            pythonDecRef();
        }

        public native void pythonDecRef();
        public native TokenStream tokenStream(String fieldName, Reader reader);
    }
      </pre>
<p>
	The <span class="codefrag">pythonExtension()</span> methods is what makes this class
	recognized as an extension class by JCC. They should be included
	verbatim as above along with the declaration of
	the <span class="codefrag">pythonObject</span> instance variable.
      </p>
<p>
	The implementation of the native <span class="codefrag">pythonDecRef()</span> method
	is generated by JCC and is necessary because it seems
	that <span class="codefrag">finalize()</span> cannot itself be native. Since an
	extension class wraps the Python instance object it's going to be
	calling methods on, its ref count needs to be decremented when this
	Java wrapper class disappears. A declaration
	for <span class="codefrag">pythonDecRef()</span> and a <span class="codefrag">finalize()</span>
	implementation should always be included verbatim as above.
      </p>
<p>
	Really, the only non boilerplate user input is the constructor of the
	class and the other native methods, <span class="codefrag">tokenStream()</span> in
	the example above.
      </p>
<p>
	The corresponding Python class(es) are implemented as follows:
      </p>
<pre class="code">
        class _analyzer(PythonAnalyzer):
            def tokenStream(_self, fieldName, reader):
                class _tokenStream(PythonTokenStream):
                    def __init__(self_):
                        super(_tokenStream, self_).__init__()
                        self_.TOKENS = ["1", "2", "3", "4", "5"]
                        self_.INCREMENTS = [1, 2, 1, 0, 1]
                        self_.i = 0
                        self_.posIncrAtt = self_.addAttribute(PositionIncrementAttribute.class_)
                        self_.termAtt = self_.addAttribute(TermAttribute.class_)
                        self_.offsetAtt = self_.addAttribute(OffsetAttribute.class_)
                    def incrementToken(self_):
                        if self_.i == len(self_.TOKENS):
                            return False
                        self_.termAtt.setTermBuffer(self_.TOKENS[self_.i])
                        self_.offsetAtt.setOffset(self_.i, self_.i)
                        self_.posIncrAtt.setPositionIncrement(self_.INCREMENTS[self_.i])
                        self_.i += 1
                        return True
                    def end(self_):
                        pass
                    def reset(self_):
                        pass
                    def close(self_):
                        pass
                return _tokenStream()
      </pre>
<p>
	When an <span class="codefrag">__init__()</span> is declared, <span class="codefrag">super()</span>
	must be called or else the Java wrapper class will not know about
	the Python instance it needs to invoke.
      </p>
<p>
	When a java extension class declares native methods for which there
	are public or protected equivalents available on the parent class,
	JCC generates code that makes it possible to
	call <span class="codefrag">super()</span> on these methods from Python as well.
      </p>
<p>
	There are a number of extension examples available in PyLucene's test
	<a href="http://svn.apache.org/viewcvs.cgi/lucene/pylucene/trunk/test">suite</a>
	and <a href="../../documentation/readme.html">samples</a>.
      </p>
</div>
    
<a name="N1035C"></a><a name="embedding"></a>
<h2 class="boxed">Embedding a Python VM in a Java VM</h2>
<div class="section">
<p>
	Using the same techniques used when writing a Python extension of a
	Java class, JCC may also be used to embed a Python VM in a Java VM.
	Following are the steps and constraints to follow to achieve this:
      </p>
<ul>
	
<li>
	  JCC must be built in shared mode.  See
          <a href="../../jcc/documentation/install.html">installation
	  instructions</a> for more information about shared mode.
	  Note that for this use on Mac OS X, JCC must also be built
	  with the link flags <span class="codefrag">"-framework", "Python"</span> in
	  the <span class="codefrag">LFLAGS</span> value.
	</li>
	
<li>
	  As described in the previous section, define one or more Java
	  classes to be "extended" from Python to provide the
	  implementations of the native methods declared on them. Instances
	  of these classes implement the bridges into the Python VM from
	  Java.
	</li>
	
<li>
	  The <span class="codefrag">org.apache.jcc.PythonVM</span> Java class is going be
	  used from the Java VM's main thread to initialize the embedded
	  Python VM. This class is installed inside the JCC egg under the
	  <span class="codefrag">jcc/classes</span> directory and the full path to this
	  directory must be on the Java <span class="codefrag">CLASSPATH</span>.
	</li>
	
<li>
	  The JCC egg directory contains the JCC shared runtime library - not
	  the JCC Python extension shared library - but a library
	  called <span class="codefrag">libjcc.dylib</span> on Mac OS X, 
          <span class="codefrag">libjcc.so</span> on Linux or <span class="codefrag">jcc.dll</span> on Windows. 
	  This directory must be added to the Java VM's shared library path
	  via the <span class="codefrag">-Djava.library.path</span> command line parameter.
	</li>
	
<li>
	  In the Java VM's main thread, initialize the Python VM by
	  calling its static <span class="codefrag">start()</span> method passing it a
	  Python program name string and optional start-up arguments
	  in a string array that will be made accessible in Python via
	  <span class="codefrag">sys.argv</span>.  Note that the program name string is
	  purely informational, and is not used by the
	  <span class="codefrag">start()</span> code other than to initialize that
	  Python variable.  This method returns the singleton PythonVM
	  instance to be used in this Java VM. <span class="codefrag">start()</span>
	  may be called multiple times; it will always return the same
	  singleton instance.  This instance may also be retrieved at any
	  later time via the static <span class="codefrag">get()</span> method defined
	  on the <span class="codefrag">org.apache.jcc.PythonVM</span> class.
	</li>
	
<li>
	  Any Java VM thread that is going to be calling into the Python VM
	  should start with acquiring a reference to the Python thread state
	  object by calling <span class="codefrag">acquireThreadState()</span> method on the
	  Python VM instance. It should then release the Python thread state
	  before terminating by calling <span class="codefrag">releaseThreadState()</span>. 
          Calling these methods is optional but strongly recommended as it
	  ensures that Python is not creating and throwing away a thread
	  state everytime the Python VM is entered and exited from a given
	  Java VM thread.
	</li>
	
<li>
	  Any Java VM thread may instantiate a Python object for which an
	  extension class was defined in Java as described in the previous
	  section by calling the <span class="codefrag">instantiate()</span> method on the 
	  PythonVM instance. This method takes two string parameters, the
	  name of the Python module and the name of the Python class to
	  import and instantiate from it. The <span class="codefrag">__init__()</span>
	  constructor on this class must be callable without any parameters
	  and, if defined, must call <span class="codefrag">super()</span> in order to
	  initialize the Java side. The <span class="codefrag">instantiate()</span> method is
	  declared to return <span class="codefrag">java.lang.Object</span> but the return
	  value is actually an instance of the Java extension class used and
	  must be downcast to it.
	</li>
      
</ul>
</div>
    
<a name="N103C4"></a><a name="python"></a>
<h2 class="boxed">Pythonic protocols</h2>
<div class="section">
<p>
	When generating wrappers for Python, JCC attempts to detect which
	classes can be made iterable:
      </p>
<ul>
	
<li>
	  When a class declares to
	  implement <span class="codefrag">java.lang.Iterable</span>, JCC makes it iterable
	  from Python.
	</li>
	
<li>
	  When a Java class declares a method called <span class="codefrag">next()</span>
	  with no arguments returning an object type, this class is made
	  iterable. Its <span class="codefrag">next()</span> method is assumed to terminate
	  iteration by returning <span class="codefrag">null</span>.
	</li>
      
</ul>
<p>
	JCC generates a Python mapping get method for a class when requested
	to do so via the <span class="codefrag">--mapping</span> command line option which
	takes two arguments, the class to generate the mapping get for and
	the Java method to use. The method is specified with its name
	followed by ':' and its Java
	<a href="http://java.sun.com/j2se/1.5.0/docs/guide/jni/spec/types.html#wp16432">signature</a>.
      </p>
<p>
      For example, <span class="codefrag">System.getProperties()['java.class.path']</span> is
      made possible by:
      </p>
<pre class="code">
        --mapping java.util.Properties 
                  'getProperty:(Ljava/lang/String;)Ljava/lang/String;'
                              # asking for a Python mapping protocol wrapper
                              # for get access on the Properties class by
                              # calling its getProperty method
      </pre>
<p>
	JCC generates Python sequence length and get methods for a class
	when requested to do so via the <span class="codefrag">--sequence</span> command line
	option which takes three arguments, the class to generate the
	sequence length and get for and the two java methods to use. The
	methods are specified with their name followed by ':' and their Java
	<a href="http://java.sun.com/j2se/1.5.0/docs/guide/jni/spec/types.html#wp16432">signature</a>. For example:
      </p>
<pre class="code">
      for i in xrange(len(hits)): 
          doc = hits[i]
          ...
      </pre>
<p>
	is made possible by:
      </p>
<pre class="code">
        --sequence org.apache.lucene.search.Hits
                   'length:()I' 
                   'doc:(I)Lorg/apache/lucene/document/Document;'
      </pre>
</div>
  
</div>
<!--+
    |end content
    +-->
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<!--+
    |start bottomstrip
    +-->
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("Last Published: " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2009-2011 <a href="http://www.apache.org/licenses/">The Apache Software Foundation.</a>
</div>
<!--+
    |end bottomstrip
    +-->
</div>
</body>
</html>
